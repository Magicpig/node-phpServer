{
  "name": "fastcgi-parser",
  "version": "0.1.1",
  "description": "FastCGI parser for low level parsing of the FastCGI protocol",
  "keywords": [
    "fastcgi,parser"
  ],
  "author": {
    "name": "Andrew Johnston",
    "email": "apjohnsto@gmail.com"
  },
  "main": "./lib/fastcgi",
  "engines": {
    "node": ">= 0.2.0"
  },
  "dependencies": {
    "vows": ">= 0.5.6"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/billywhizz/node-fastcgi-parser.git"
  },
  "readme": "# FastCGI Parser for Node.js\n\nA very basic FastCGI parser for low level parsing of the FastCGI protocol. Can be used to build FastCGI applications which are called from an existing web server (nginx/lighttpd/apache etc.) or to interact with FastCGI applications.\n\n# Dependencies\n- currently using creatonix's buffer_extras module for binary packing. this will be replaced by a more efficient c++ addon or i might make the binary packing/unpacking pluggable\n  \n# Todo\n\t\n## Usage (see tests/test.js)\n\n# Server Configuration\n\n## Lighttpd \n\n\tfastcgi.server = ( \".js\" =>\n\t\t( \"localhost\" =>\n\t\t\t(\n\t\t\t\t\"socket\" => \"/tmp/nginx.sock\",\n\t\t\t\t\"check-local\" => \"disable\"\n\t\t\t)\n\t\t)\n\t)\n\t\n## nginx\n\n\tlocation ~ \\.js$ {\n\t\tfastcgi_pass   unix:/tmp/nginx.sock;\n\t\tfastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n\t}\n\n# API\n\nfastcgi.parser\n\nparser.encoding = [\"utf8\"|\"ascii\"|\"binary\"]\n\ndefault is utf8. this determines the encoding used when reading the body of an STDIN/STDOUT/STDERR record. utf8 or ascii mean no onBody callback will be fired and the record in onRecord will have a body property set to the correctly encoded string.\nbinary will mean no body property is set on the record returned in the onRecord callback and chunks of the body will be emitted in the onBody callback as they arrive. \n\nparser.reset = function()\n\nresets the parser so it can be executed on a new stream. you should use this aftaer an error or when re-using an already existing parser on a new stream. \n\nparser.init = function()\n\ncompletely reinitialises the parser. calls parser.reset as well as setting encoding back to default (utf8) and clearing all callback handlers\n\nparser.execute = function(buffer) \n\nparses the buffer. calls callback.\n\nfastcgi.constants\n\n\t\"version\": 1,\n\t\"record\": {\n\t\t\"FCGI_BEGIN\": 1,\n\t\t\"FCGI_ABORT\": 2,\n\t\t\"FCGI_END\": 3,\n\t\t\"FCGI_PARAMS\": 4,\n\t\t\"FCGI_STDIN\": 5,\n\t\t\"FCGI_STDOUT\": 6,\n\t\t\"FCGI_STDERR\": 7,\n\t\t\"FCGI_DATA\": 8,\n\t\t\"FCGI_GET_VALUES\": 9,\n\t\t\"FCGI_GET_VALUES_RESULT\": 10,\n\t\t\"FCGI_UNKNOWN_TYPE\": 11\n\t},\n\t\"keepalive\": {\n\t\t\"OFF\": 0,\n\t\t\"ON\": 1\n\t},\n\t\"parser\": {\n\t\t\"state\": {\n\t\t\t\"HEADER\": 0,\n\t\t\t\"BODY\": 1,\n\t\t\t\"PADDING\": 2\n\t\t}\n\t},\n\t\"general\": {\n\t\t\"FCGI_HEADER_LEN\": 8,\n\t\t\"FCGI_MAX_BODY\": Math.pow(2,16)\n\t},\n\t\"errors\": {\n\t\t\"BUFFER_OVERFLOW\": {\n\t\t\t\"err\": 1,\n\t\t\t\"description\": \"buffer overflow\"\n\t\t},\n\t\t\"MAX_BODY_EXCEEDED\": {\n\t\t\t\"err\": 2,\n\t\t\t\"description\": \"a body greater than maximum body size was read/written\"\n\t\t}\n\t},\n\t\"flags\": {\n\t\t\"FCGI_KEEP_CONN\": 1\n\t},\n\t\"role\": {\n\t\t\"FCGI_RESPONDER\": 1,\n\t\t\"FCGI_AUTHORIZER\": 2,\n\t\t\"FCGI_FILTER\": 3\n\t},\n\t\"protocol\": {\n\t\t\"status\": {\n\t\t\t\"FCGI_REQUEST_COMPLETE\": 0,\n\t\t\t\"FCGI_CANT_MPX_CONN\": 1,\n\t\t\t\"FCGI_OVERLOADED\": 2,\n\t\t\t\"FCGI_UNKNOWN_ROLE\": 3\n\t\t}\n\t},\n\t\"values\": {\n\t\t\"FCGI_MAX_CONNS\": \"FCGI_MAX_CONNS\",\n\t\t\"FCGI_MAX_REQS\": \"FCGI_MAX_REQS\",\n\t\t\"FCGI_MPXS_CONNS\": \"FCGI_MPXS_CONNS\"\n\t}\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/billywhizz/node-fastcgi-parser/issues"
  },
  "_id": "fastcgi-parser@0.1.1",
  "dist": {
    "shasum": "24cfd611099a15e33bf8267fb919de4b5c55ac16"
  },
  "_from": "fastcgi-parser"
}
